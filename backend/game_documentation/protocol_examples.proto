// Protobuf örnekleri - ağ protokolleri için mesaj tanımları.
// Amaç: basit, verimli ve genişletilebilir (auth, input, snapshot, entity update).
// Notlar:
// - proto3 kullanılıyor.
// - Bu dosya örnek amaçlıdır; gerçek uygulamada paket isimleri ve go_package/ts options güncellenmelidir.
// - Ağ üzerinde ikili (binary) protobuf mesajları gönderilmesi önerilir (JSON yerine).
syntax = "proto3";

package hobiegame.protocol;

// Örnek Go paket ayarı (gerektiğinde güncelle)
// option go_package = "github.com/yourname/My2DHobieMMORPGGame/game_protocol;hobieproto";

// Genel zaman/tick tipi
// Sunucu authoritative: tüm fizik/simülasyon sunucuda çalışır; client sadece input gönderir ve snapshot alır.

////////////////////////////////////////////////////////////////////////////////
// Temel yardımcı mesajlar
////////////////////////////////////////////////////////////////////////////////

// 2D vektör (float).
message Vec2 {
  float x = 1;
  float y = 2;
}

// Basit pozisyon/velocity container (kullanımı kolaylaştırmak için).
message Transform {
  Vec2 position = 1;
  Vec2 velocity = 2;
  float rotation = 3; // radyan cinsinden (gerekirse)
}

////////////////////////////////////////////////////////////////////////////////
// Paket envelope - tek bir kanal üzerinden farklı tipte mesaj göndermek için.
////////////////////////////////////////////////////////////////////////////////
message Packet {
  // Sunucu veya client tarafından gönderilen paketlerin admin/izleme amaçlı tick'i
  uint32 tick = 1;

  // Bu paket içinde hangi tip veri olduğunu belirlemek için oneof kullanıyoruz.
  oneof payload {
    AuthRequest auth_request = 10;
    AuthResponse auth_response = 11;
    Heartbeat heartbeat = 12;

    // Client -> Server: oyuncu input'u
    InputFrame input_frame = 20;

    // Server -> Client: anlık tam veya delta snapshot
    Snapshot snapshot = 30;

    // Server -> Client veya Server -> Server: tek entity güncellemesi (küçük event'ler için)
    EntityUpdate entity_update = 31;

    // Hata / bilgi mesajları
    ServerMessage server_message = 40;
  }
}

////////////////////////////////////////////////////////////////////////////////
// 1) Authentication
////////////////////////////////////////////////////////////////////////////////

// Client -> Server: kimlik doğrulama isteği (örnek: başlangıçtaki login veya token refresh)
message AuthRequest {
  string username = 1;
  // Parola yerine client-side hash/nonce kombinasyonu veya OAuth token kullanılması önerilir.
  string password_hash = 2;
  string client_version = 3;
  string platform = 4; // "web", "linux", "win", "android" vb.
  // Eğer session-based auth kullanıyorsan, mevcut session token'ı ekleyebilirsin.
  string session_token = 5;
}

// Server -> Client: kimlik doğrulama yanıtı
message AuthResponse {
  bool success = 1;
  string session_token = 2; // başarılıysa verilir
  string reason = 3;         // başarısızsa neden
  uint64 server_time = 4;    // unix epoch ms
  uint32 recommended_tick = 5; // client için önerilen tick rate (ör. 50)
}

////////////////////////////////////////////////////////////////////////////////
// 2) Heartbeat / Ping
////////////////////////////////////////////////////////////////////////////////
message Heartbeat {
  uint64 client_time = 1; // client timestamp (ms)
  uint32 nonce = 2;       // eşleşme için rastgele sayı
}

////////////////////////////////////////////////////////////////////////////////
// 3) Input model (Client -> Server)
////////////////////////////////////////////////////////////////////////////////

// Bir veya daha fazla eylem içeren input frame.
// Her frame'in sırası (seq) ve server'ın tick'ine karşılık gelen client_time gönderilir.
message InputFrame {
  uint32 seq = 1;           // artan sıra numarası (replay / ack için)
  uint64 client_time = 2;   // client timestamp (ms)
  repeated InputAction actions = 3;
  // Optional: prediction id / local reconciliation bilgisi
  uint32 last_acknowledged_server_tick = 4;
}

message InputAction {
  // Hangi tip eylem olduğunu belirtir.
  enum ActionType {
    UNKNOWN = 0;
    MOVE = 1;       // hareket komutu (örn. joystick)
    ATTACK = 2;     // temel saldırı
    SKILL = 3;      // skill / ability kullanımı
    INTERACT = 4;   // etkileşim (E tuşu vb.)
    EMOTE = 5;      // görselleştirme/sozluk
  }
  ActionType type = 1;

  // Hareket tipi ise normalize edilmiş yön vektörü.
  // MOVE için kullan: x/y ∈ [-1,1]
  Vec2 move_dir = 2;

  // Hedef entity id (ör. attack/skill/interact için)
  uint64 target_entity_id = 3;

  // Kullanılan skill id (skill action için)
  uint32 skill_id = 4;

  // Buton basılıp bırakılma durumları, duration, vs.
  bool pressed = 5;

  // Ek metadatalar (ör: analog magnitude) - opsiyonel
  float magnitude = 6;
}

////////////////////////////////////////////////////////////////////////////////
// 4) Snapshot / World state (Server -> Client)
////////////////////////////////////////////////////////////////////////////////

// Snapshot; sunucu belirli aralıklarla oyuncuya göndereceği tam veya delta snapshot'ları paketler.
// - Tam snapshot büyük ama basit; delta snapshot daha küçük ama client'ın önceki durumunu bilmesini gerektirir.
// - `full` bayrağı snapshot'un tam mı yoksa delta mı olduğunu ifade eder.
message Snapshot {
  uint32 server_tick = 1; // server tick indeksi
  bool full = 2;         // true => tam snapshot, false => delta
  repeated EntityState entities = 3;  // entity listesi (interest management ile sınırlanır)
  // İsteğe bağlı: oyuncu ile ilgili özel veriler (ör. local player snapshot)
  PlayerState local_player = 4;
}

// Tüm entity durumunu taşıyan yapı (tam snapshot için)
message EntityState {
  uint64 id = 1;
  EntityType type = 2;
  Transform transform = 3;
  uint32 health = 4;
  uint32 max_health = 5;
  uint32 state_flags = 6; // bitfield: ör. 1 = dead, 2 = invulnerable, ...
  uint32 animation_id = 7;
  // ek data: ekipman, görünüm id, owner id vs.
  uint64 owner_id = 10;
  // metadata: küçük key-value olarak string-based (gerektiğinde kullanılabilir)
  map<string, string> meta = 20;
}

// Delta/patch tarzı küçük güncellemeler için EntityUpdate kullanılır.
message EntityUpdate {
  uint64 id = 1;

  // Her alan opsiyonel düşünülür; sadece değişen alanlar gönderilir.
  // Proto3'te field'ların "optional" anahtar kelimesi kullanılabilir (sürüm dependent).
  // Burada basitlik için null-able semantics yerine 0/varsayılan ile değil, ayrı boole işaretçileri
  // kullanma örneği verilmektedir (uygulamada daha sıkıntısız yöntemler tercih edilebilir).
  // Basit örnek:
  Transform transform = 2;
  uint32 health = 3;
  uint32 state_flags = 4;
  uint32 animation_id = 5;

  // Eğer entity spawn veya despawn ise event tipi:
  enum UpdateType {
    UPDATE = 0;
    SPAWN = 1;
    DESPAWN = 2;
  }
  UpdateType update_type = 10;
}

message PlayerState {
  uint64 player_id = 1;
  Transform transform = 2;
  uint32 health = 3;
  uint32 mana = 4;
  // inventory checksum veya version
  uint32 inventory_version = 10;
}

////////////////////////////////////////////////////////////////////////////////
// 5) Entity & enums
////////////////////////////////////////////////////////////////////////////////
enum EntityType {
  ET_UNKNOWN = 0;
  ET_PLAYER = 1;
  ET_NPC = 2;
  ET_DAEMON = 3;       // düşman / daemon
  ET_PROJECTILE = 4;
  ET_ITEM = 5;
  ET_ENV_OBJECT = 6;
}

////////////////////////////////////////////////////////////////////////////////
// 6) Server message / meta
////////////////////////////////////////////////////////////////////////////////
message ServerMessage {
  enum Level {
    INFO = 0;
    WARNING = 1;
    ERROR = 2;
  }
  Level level = 1;
  string text = 2;
  uint64 timestamp = 3;
}

////////////////////////////////////////////////////////////////////////////////
// 7) Uygulama / entegrasyon notları (yorum satırı içinde)
// - Field numaralarını ileride değiştirmemek için yeni alan eklerken 100+ gibi bloklar ayır.
// - Snapshot'ları sıkıştırmak (zlib/snappy) veya delta encoding uygulamak bant genişliği için önemlidir.
// - Binary protobuf mesajlarını WebSocket üzerinde base64'lemeye gerek yoktur; binary frame kullan.
// - Tüm client input'larını server doğrular; client tarafı yalnızca pür render ve prediction yapmalı.
// - "interest management" (AOI) uygulayarak her client'a yalnızca ilgili entity'leri gönder.
// - Eğer daha küçük bir protokol istersen: movement/transform'ları 16-bit fixed-point ile paketleyerek boyutu azaltabilirsin.
// - Güvenlik: auth sonrası session_token ile yetkilendirme; tüm bağlantılar TLS üzerinden (WSS) olmalı.
////////////////////////////////////////////////////////////////////////////////
